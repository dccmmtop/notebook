# HTTP

## 代理

### 代理使用同一种协议，网关使用不同的协议连接端

### 作用

- 监视流量并修改
- 儿童过滤器
- 安全防火墙
-  缓存
- 反向代理 假扮服务器
- 文档访问控制，统一输入密码
- 转码器 图片格式，语言
- 匿名者

	- 从报文中删除身份特征，ip,首部，cookie等

### 层级结构

- 静态

	- 固定顺序转发

- 动态

	- 负载均衡
	- 就近路由
	- 协议类型路由

### 如何获取流量

- 修改客户端网络配置

	- 不设置代理 发送相对URI路径
	- 有代理发送完整路径

- 修改路由设备网络

	- 在客户端不参与的情况下拦截网络流量，依赖流量交换设备和路由设备

- 修改DNS命名空间
- 修改web服务器

	- 重定向

### 追踪报文

- Via 首部 

	- 记录经过的每个中间节点
	- 用来检测是否有路由循环
	- 组成

		- 协议名
		- 协议版本
		- 节点名
		- 节点注释

- trace 方法

	- Max-Forwards

		- 整数
		- 本报文还可以被转发的次数
		- 每经过一个节点数量减一

### 代理认证

### 代理的互操作 

- 保留不支持的首部和方法，向下转发
- OPTIONS方法

	- URI 是*， 查看服务支持的所有方法
	- URLI 是具体资源，查看对该资源支持的方法

- Allow 首部

	- 对资源所支持的方法列表

## 缓存

### 问题

- 冗余数据传输
- 带宽瓶颈
- 瞬间堵塞
- 距离时延

### 区分命中和未命中的情况

- Date首部

  将响应中Date首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可以认为这是一条缓存的响应。

### 缓存的层次结构

在实际中，实现层次化（hierarchy）的缓存是很有意义的，在这种结构中，在较小缓存中未命中的请求会被导向较大的父缓存（parent cache），由它来为剩下的那些“提炼过的”流量提供服务。图7-9显示了一个两级的缓存层次结构。[插图]其基本思想是在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能更强的缓存来装载多用户共享的文档。

### 网状缓存、内容路由以及对等缓存

### 处理步骤

- 1. 接收

	- 缓存从网络中读取抵达的请求报文

- 2. 解析

	- 缓存对报文进行解析，提取出URL和各种首部

- 3. 查询

	- 存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保存在本地）

- 4. 新鲜度检测

	- 缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新

- 5. 创建相应

	- 缓存会用新的首部和已缓存的主体来构建一条响应报文

- 6. 发送

	- 缓存通过网络将响应发回给客户端

- 7. 日志

	- 缓存可选地创建一个日志文件条目来描述这个事务

- 流程图

### 保持副本的新鲜

- 说明

  可能不是所有的已缓存副本都与服务器上的文档一致。毕竟，这些文档会随着时间发生变化。报告可能每个月都会变化。在线报纸每天都会发生变化。财经数据可能每过几秒钟就会发生变化。如果缓存提供的总是老的数据，就会变得毫无用处。已缓存数据要与服务器数据保持一致。

- 再验证

	- 缓存过期不代表文档变化，而是需要核对了
	- 有变化

		- 获取一份新的文档

	- 无变化

		- 只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新

	- 条件再验证

	  HTTP的条件方法可以高效地实现再验证。HTTP允许缓存向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。通过这种方式，将新鲜度检测和对象获取结合成了单个条件GET。向GET请求报文中添加一些特殊的条件首部，就可以发起条件GET。只有条件为真时，Web服务器才会返回对象。

	- If-Modified-Since:Date

	  If-Modified-Since首部可以与Last-Modified服务器响应首部配合工作。原始服务器会将最后的修改日期附加到所提供的文档上去。当缓存要对已缓存文档进行再验证时，就会包含一个If-Modified-Since首部，其中携带有最后修改已缓存副本的日期
	  如果在此期间内容被修改了，最后的修改日期就会有所不同，原始服务器就会回送新的文档。否则，服务器会注意到缓存的最后修改日期与服务器文档当前的最后修改日期相符，会返回一个304 NotModified响应。

		- 自指定日期后，文档被修改了，为 true
		- 自指定日期后，文档没被修改过，为 false
		- 是否命中

			- 再验证命中

				- 服务器返回一个小的HTTP 304 Not Modified响应

			- 再验证未命中

				- HTTP 200 OK响应

			- 对象被删除

				- 404 Not Found响应

		- 无法使用该类型验证得场景

			- 内容不变，时间变
			- 不重要得内容变化
			- 无法得到修改时间
			- 亚秒间隙发生变化，秒级粒度不够

	- If-None-Match：实体标签再验证

	  HTTP允许用户对被称为实体标签（ETag）的“版本标识符”进行比较。实体标签是附加到文档上的任意标签（引用字符串）。它们可能包含了文档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样，如果实体标签被修改了，缓存就可以用If-None-Match条件首部来GET文档的新副本了

		- 缓存中已有某些副本  If-None-Match:"v2.4,v2.5"
		- 强弱验证器

			-  弱: 改变不重要得内容时，缓存不失效
			- 强: 任何改变都会失效
			- 服务器会用前缀“W/”来标识弱验证器
ETag: W/"v2.6"
If-None-Match: W/"v2.6"

	- 选择

		- 服务器只回送了一个Last-Modified，客户端就可以使用If-Modified-Since验证
		- 实体标签和最后修改日期都提供了，客户端就应该同时使用这两种再验证方案

			- 只有这两个条件都满足时，才能返回304 Not Modified响应

### 控制缓存的能力

- 首部 Cache-Control:max-age (推荐)

	- max-age=600 最大生存时间为600秒

- Expires首部

	- 指定绝对日期，依赖机器本身时间

*XMind: ZEN - Trial Version*
''



![](../images/20210401215241697_19924.png =664x)
![](../images/20210407071936189_27376.png =619x)
SLL 握手
![](../images/20210407072355013_23129.png =666x)
服务器证书
![](../images/20210407072740387_14740.png =778x)
代理
![](../images/20210407075322514_20846.png =628x)

![](../images/20210407082646367_28526.png =633x)