---
title: RocketMQ 基本概念和高级原理
date: 2023-07-25 22:05:40
tags: [RocketMQ]
---

## 基础概念

### 消息模型

RocketMQ 主要由 Producer、Broker、Consumer 三部分组成，其中 Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个 Topic 的消息，每个 Topic 的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个 Topic 中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个 Consumer 实例构成。
图示如下：

![](../images/2023-08-02-21-52-42.png)

图中的主题（Topic）, 队列（Queue）, 消费者（Consumer），生产者（Producer）已经熟悉了， 但是图中的消费组（Consumer Group）和生产组（Producer Group）又是什么呢？

### 消息消费者
负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从 Broker 服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：

- 拉取式消费
- 推动式消费。

拉取式消费的应用通常主动调用 Consumer 的拉消息方法从 Broker 服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。

推动式消费模式下 Broker 收到数据后会主动推送给消费端，该消费模式一般实时性较高。

#### 消费者组

消费者同样会把同一类 Consumer 组成一个集合，叫做消费者组，这类 Consumer 通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，**实现负载均衡**和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的 Topic。RocketMQ 支持两种消息模式： **集群消费（Clustering）和广播消费（Broadcasting）**

集群消费模式下，相同 Consumer Group 的每个 Consumer 实例平均分摊消息。
广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收全量的消息。

RocketMQ 中，消费组相当于订阅者，订阅 Topic 是以一个**消费组**来订阅的，发送到 Topic 的消息，只会被订阅此 Topic 的**每个 group 中的一个 consumer 消费**。 一个消费组中可以包含多个消费者， **不同的消费组**之间是互相不受影响的，也就是说一条消息，消费组 1 消费过了， 也会被消费组 2 消费。也就是说，**一个 队列 (Queue)，只能被消费组里的一个消费者消费，但是可以同时被多个消费组消费**，消费组里的每个消费者是关联到一个 Queue 的，因此有这样的说法：**对于一个 topic, 同一个 group 中的消费者个数和队列个数最好一致，这样能得到充分的使用，也不会浪费资源。**

既然多个消费组都可以消费同一条消息。那你可能会好奇我们有怎么记住每一个消费组消费到哪条消息了呢？首先为了保证消息被多个消费组消费，一个消费组消消费完消息后一定不会删除，在 RocketMQ 中使用的是**消费位置（offset）记录每个消费组在每个队列上消费到哪一条消息**。每消费一条消息消费位置就会加 1. 当所有订阅该该主题的所有消费者组都消费了这条消息以后， 才能删除这条消息。

### 消息生产者
负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到 broker 服务器。RocketMQ 提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要 Broker 返回确认信息，单向发送不需要。

生产者中，会把同一类 Producer 组成一个集合，叫做生产者组，这类 Producer 发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则 Broker 服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。

生产组则是发布者， 一个生产组中可以有多个生产者。生产者在生产消息时可以在采用随机， 轮询， 哈希等方式向任何队列发送消息。

### 主题

表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是 RocketMQ 进行消息订阅的基本单位。
同一个 Topic 下的数据，会分片保存到不同的 Broker 上，而每一个分片单位，就叫做 MessageQueue。**MessageQueue 是生产者发送消息与消费者消费消息的最小单位。** MessageQueue 是真实存在的物理文件，而 Topic 只是人为的将消息进行分类的名称


### 名字服务（Name Server）

名称服务充当路由消息的提供者。Broker Server会在启动时向所有的Name Server注册自己的服务信息，并且后续通过心跳请求的方式保证这个服务信息的实时性。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。

## 消息存储


### 何时存储消息

分布式队列有高可用的要求，所以数据要持久化存储。存储过程简述如下：
1. MQ 收到一条消息后，需要想生产者返回一个 ACK 相应，并将消息存储起来。
2. MQ push 一条消息给消费者后，等待消费者的 ACK 相应，需要将消息标记成已消费。如果没有标记已消费，MQ 不断地尝试往消费者推送这条消息
3. MQ 要定期的删除一些消息，这样才能保证服务一直可用
   
删除消息的配置：

```conf
# 删除文件的时间点，默认是凌晨 4 点
deleteWhen = 04
# 文件保留时间，默认是 48 小时
fileReservedTime = 48
```

### 消息存储介质
RocketMQ 采用的是类似 kafka 的文件存储机制，即直接用磁盘文件保存信息，而不需借助 MySQL 这一类的索引工具。

#### 磁盘存储能保证速度吗？
磁盘如果使用得当，完全可以匹配上网络传输速度。目前高性能的磁盘，顺序读写速度可以达到 600M/S , 超过了一般的网卡传输速度，但是磁盘的随机读写速度大概只有 100KB/S, 和顺序读写的性能相差 6000 倍！因为有如此巨大的速度差别，好的消息队列会比普通的消息队列速度快多个数量级。RocketMQ 的消息顺序写，保证了消息存储的速度。

#### 零拷贝加速文件读写
Linux 操作系统分为【用户态】和【内核态】，文件操作、网络操作需要涉及到这两种形态的转换，免不了进行数据复制。

一台服务器把本机文件内容发送到客户端，一般分为两个步骤：
1. read；读取本地文件内容
2. write：将读取内容通过网络发送出去。

这两步看似简单的操作，实际进行了 4 次数据复制，分别是：
1. 从磁盘复制数据到内核态内存
2. 从内核态内存复制到用户态内存
3. 然后从用户态内存复制到网络驱动的内核态内存
4. 最后是从网络驱动的内核态内存复制到网卡中进行传输。

RocketMQ 采用 mmap 的方式。可以省区向用户态的复制，提高速度，这种机制在 java 中是通过 NIO 包中的 MappedByteBuffer 实现的。 RocketMQ 充分利用了上述的特性，也就是所谓的零拷贝技术，提高消息存储和网路发送的速度。

大需要注意的是：采用 MappedByteBuffer 这种内存映射的方式有几个限制，其中之一是一次只能映射 1.5G~2G 的文件只用户态的虚拟内存，这也是为何 RocketMQ 默认设置单个 CommotLog 的大小是 1G 的原因了。

关于零拷贝，JAVA 的 NIO 中提供了两种实现方式， mmap 和 sendfile, 其中 mmap 适合比较小的文件，而 sendfile 适合传递比较大的文件。

> 联系方式：dccmmtop@foxmail.com