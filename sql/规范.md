# 规范
- 非功能性需求
- 数据库对象名称必须使用小写字母，如多个单词组合须用下划线分割。

- 数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）。
- 数据库对象的命名要能做到见名识意，且不允许超过32个字符。
- 临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀，历史表以his_为前缀。
- 索引命名规则:主键索引命名以pk_开头，唯一索引以uniq_开头，一般索引已idx_开头。
- 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。
- 所有业务表必须使用Innodb存储引擎。
- 数据库和表的字符集统一使用UTF8，必要时候使用utf8mb4。
- 所有表和字段都需要添加注释。
- 不建议使用MySQL分区表，建议采用多个普通表取代分区表。部分历史表可酌情使用分区表。
- 禁止在数据库中存储图片，文件等大的二进制数据。
- 尽量做到冷热数据分离，减小表的宽度。
- 每个数据库中的表的数量不建议超过2000个。
- 建议每个表大小不超过16g，行数不超过2000w，否则建议分表。
- 禁止使用存储过程，触发器，Event。
- 项目组需要定义Mysql数据库的事务隔离级别，Mysql默认为可重复读，Oracle默认为提交读。
- 优先选择符合存储需要的最小的数据类型，比如IP类型在存储前使用inet_aton转换，读取前使用inet_ntoa转换，或者使用INT UNSIGNED存储IPv4，不要用char(15)；非负型的数据使用无符号整型来存储，可扩大数据范围。
- 禁止使用BLOB数据类型，一般不建议使用TEXT类型，TEXT类型可以存储64k的数据，TEXT特殊情况需要变更评审中说明。
- 禁止使用枚举ENUM类型，可以使用TINYINT代替。
- 使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间，不建议使用字符类型(CHAR、VARCHAR)存储日期。存储年使用YEAR类型。存储日期使用DATE类型。 存储时间(精确到秒)建议使用TIMESTAMP类型。
- 同财务相关的金额类数据必须使用decimal类型，不建议使用float，double。
- 根据业务区分使用tinyint/int/bigint，分别会占用1/4/8字节。
- 根据业务区分使用char/varchar。字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高；字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间，VARCHAR(N)中的N表示字符数而非字节数。
- 强烈建议每个字段定义为NOT NULL并设默认值。
- 自增长标识建议采用int或bigint数据类型，如果该表有大量的删除及再写入就使用bigint,反之int就够用。
- 使用varchar(20)存储手机号，不要使用整数。
- 限制每张表上的索引数量，建议单张表索引不超过5个。
- 每个Innodb表必须有主键，推荐使用UNSIGNED整数为主键；不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引），不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）；主键建议使用自增ID值(NOT NULL PRIMARY KEY AUTO_INCREMENT)。
- "索引列选择:
- 1、出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列；
- 2、包含在ORDER BY、GROUP BY、DISTINCT中的字段，并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好，一般where子句的列在前；
- 3、多表join的关联列。"
- "索引列顺序的选择：
- 1、区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）；
- 2、尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；
- 3、使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。"
- 避免建立冗余索引和重复索引。比如index(a,b,c)、index(a,b)、index(a)，保留index(a,b,c)即可。
- 对于频繁的查询优先考虑使用覆盖索引。覆盖索引就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引。
- 禁止使用外键约束。
- 连接条件的数据类型必须一致，避免数据类型的隐式转换，比如where id = '111'， id为int类型，隐式转换导致索引无法使用。表与表之间的关联键上建议建立索引。
- 避免使用双%号的查询条件，影响索引的使用，如果无前置%,只有后置%，是可以用到列上的索引的。
- 定义联合索引(a,b,c)时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧(非引导列位置)。
- 使用left join或 not exists来优化not in操作，not in通常不会使用索引。
- 对应同一列进行or判断时，使用in代替or，in的值不要超过500个。In可以更有效使用索引，or极少使用到索引。
- WHERE从句中禁止对列进行函数转换和计算，将导致索引无法使用。
- 对于过长的VARCHAR字段不建议建立索引。建议优先考虑前缀索引,或添加CRC32或MD5伪列并建立索引。
- 建议使用预编译语句进行数据库操作，减少SQL编译所需要的时间并能避免SQL注入。
- 程序连接不同的数据库使用不同的账号，禁止跨库访问。
- 禁止使用SELECT *语法，必须使用SELECT col1,col2 查询。
- 禁止使用不含字段列表的INSERT语句。必须使用insert into table_name(col1,col2,col3) values(val1,val2,val3)，禁止使用insert into table_name values(val1,val2,val3)。
- 避免使用子查询，可以把子查询优化为join操作。一般子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。子查询的结果集不能使用索引，且需要使用临时表。
- 避免使用JOIN关联太多的表，禁止超过3个。每多关联一个表，都需要连接缓存(join_buffer_size),并且使用临时表，可能导致性能下降和内存泄露的问题。关联条件数据类型必须一致。
- 减少同数据库的交互次数，尽量合并多个相同的操作到一起，可以提高处理效率。
- 禁止使用order by rand() 进行随机排序，会对数据重复扫描，消耗大量的CPU和IO及内存资源，降低性能。
- 在明显不会有重复值时使用UNION ALL而不是UNION。
- 拆分复杂的大SQL为多个小SQL。
- 分页查询语句全部都需要带有排序条件。
- 超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作。大批量操作可能会造成严重的主从延迟、binlog日志大量写，大事务阻塞等问题。
- 对于大表必须使用pt-online-schema-change修改表结构，且在业务低峰期操作。正常大表修改表结构的锁表行为对系统可用性影响非常大。
- 禁止为程序使用的账号赋予super权限，对于程序连接数据库账号，遵循权限最小化原则。
- 对同一表的多次alter操作必须合并为一次操作，防止多次锁表问题。
- 禁止在数据库中存储明文密码。
- 应用连接数据库时，要求使用域名连接。
- 应用连接数据库时，密码必须使用密文方式连接。
- 我行Mysql数据库仅支持社区版，一般不建议使用MariaDB、Percona等其他分支。
- Mysql版本一般采用5.7版本，采用主从或者主主架构。后续可考虑使用8.0版本，使用MGR高可用。不允许存在单点风险。
- 所有新上线数据库或者新增表变更，必须提供完整的数据生命周期策略表格。
- 删除或锁定与数据库运行、维护等工作无关的账号及匿名账号，数据库用户密码要求至少8位，须包含大、小写字母、数字和特殊字符。
- 对于单节点Mysql数据库来说，一般连接数(max_connects)不允许超过1000。
- 业务繁忙系统，建议应用采用读写分离机制，分流查询业务至MySQL从库。
